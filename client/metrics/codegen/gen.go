package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/golang/protobuf/proto"
	dpb "github.com/golang/protobuf/protoc-gen-go/descriptor"
	pb "github.com/sgielen/rufs/proto"
	strcase "github.com/stoewer/go-strcase"
)

func main() {
	var out bytes.Buffer
	out.WriteString("package metrics\n")
	out.WriteString("\n")
	out.WriteString("// This file is generated by client/metrics/codegen/gen.go.")
	out.WriteString("\n")
	out.WriteString("import (\n")
	out.WriteString("	\"time\"\n")
	out.WriteString("\n")
	out.WriteString("	pb \"github.com/sgielen/rufs/proto\"\n")
	out.WriteString(")\n")

	var counterMetrics, distributionMetrics []string

	vs := pb.PushMetricsRequest_UNKNOWN.Descriptor().Values()
loop:
	for i := 0; vs.Len() > i; i++ {
		ev := vs.Get(i)
		if ev.Number() == pb.PushMetricsRequest_UNKNOWN.Number() {
			continue
		}
		ed := ev.Options().(*dpb.EnumValueOptions)
		mt, err := proto.GetExtension(ed, pb.E_PushMetricsRequest_MetricType)
		if err != nil {
			log.Fatalf("Failed to get metric type for %s: %v", ev.Name(), err)
		}
		fs, err := proto.GetExtension(ed, pb.E_PushMetricsRequest_MetricFields)
		if err != nil {
			fs = []string{}
		}
		name := string(ev.Name())
		fields := fs.([]string)
		fieldsSignature := ""
		if len(fields) > 0 {
			fieldsSignature = " " + strings.Join(fields, ", ") + " string,"
		}
		arg := "v int64"
		transformation := "float64(v)"
		namePrefix := "E R R O R"
		internalFunction := " E R R O R"
		switch *(mt.(*pb.PushMetricsRequest_MetricType)) {
		case pb.PushMetricsRequest_TIME_GAUGE:
			namePrefix = "Set"
			internalFunction = "setGauge"
			arg = "v time.Time"
			transformation = "float64(v.UnixNano()) / 1000.0"
		case pb.PushMetricsRequest_INT64_GAUGE:
			namePrefix = "Set"
			internalFunction = "setGauge"
		case pb.PushMetricsRequest_COUNTER:
			namePrefix = "Add"
			internalFunction = "increaseCounter"
			counterMetrics = append(counterMetrics, fmt.Sprintf("pb.PushMetricsRequest_%s", name))
		case pb.PushMetricsRequest_DISTRIBUTION:
			namePrefix = "Append"
			internalFunction = "appendDistribution"
			distributionMetrics = append(distributionMetrics, fmt.Sprintf("pb.PushMetricsRequest_%s", name))
		default:
			out.WriteString("\n")
			fmt.Fprintf(&out, "// Unsupported metric type %s\n", mt)
			continue loop
		}

		out.WriteString("\n")
		fmt.Fprintf(&out, "func %s%s(circles []string,%s %s) {\n", namePrefix, strcase.UpperCamelCase(name), fieldsSignature, arg)
		fmt.Fprintf(&out, "	%s(circles, pb.PushMetricsRequest_%s, []string{%s}, %s)\n", internalFunction, name, strings.Join(fields, ", "), transformation)
		out.WriteString("}\n")
	}

	out.WriteString("\n")
	out.WriteString("func isCounter(t pb.PushMetricsRequest_MetricId) bool {\n")
	out.WriteString("	switch t {\n")
	fmt.Fprintf(&out, "	case %s:\n", strings.Join(counterMetrics, ", "))
	out.WriteString("		return true\n")
	out.WriteString("	default:\n")
	out.WriteString("		return false\n")
	out.WriteString("	}\n")
	out.WriteString("}\n")

	out.WriteString("\n")
	out.WriteString("func isDistributionMetric(t pb.PushMetricsRequest_MetricId) bool {\n")
	out.WriteString("	switch t {\n")
	fmt.Fprintf(&out, "	case %s:\n", strings.Join(distributionMetrics, ", "))
	out.WriteString("		return true\n")
	out.WriteString("	default:\n")
	out.WriteString("		return false\n")
	out.WriteString("	}\n")
	out.WriteString("}\n")

	ioutil.WriteFile(os.Args[1], out.Bytes(), 0644)
}
